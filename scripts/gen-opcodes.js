"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gen = gen;
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const baseOpcodes = [
    { name: 'OP_nop', doc: 'No operation' },
    { name: 'OP_push_i32', imm: [{ name: 'value', size: 4 }], doc: 'Push 32-bit integer constant' },
    { name: 'OP_push_const', imm: [{ name: 'index', size: 2 }], doc: 'Push constant pool entry (index)' },
    { name: 'OP_get_loc', imm: [{ name: 'index', size: 1 }], feature: 'shortOpcodes', doc: 'Load local (short index)' },
    { name: 'OP_get_loc_u16', imm: [{ name: 'index', size: 2 }], doc: 'Load local (u16 index)' },
    { name: 'OP_put_loc', imm: [{ name: 'index', size: 1 }], feature: 'shortOpcodes', doc: 'Store local (short index)' },
    { name: 'OP_put_loc_u16', imm: [{ name: 'index', size: 2 }], doc: 'Store local (u16 index)' },
    { name: 'OP_add', doc: 'Numeric addition' },
    { name: 'OP_array_new', imm: [{ name: 'initialCapacity', size: 2 }], doc: 'Create array with initial capacity' },
    { name: 'OP_array_push', doc: 'Push TOS into array (array ref below top)' },
    { name: 'OP_drop', doc: 'Drop top of stack' },
    { name: 'OP_dup', doc: 'Duplicate top of stack' },
    { name: 'OP_jmp', imm: [{ name: 'offset', size: 2 }], doc: 'Unconditional jump (relative signed 16)' },
    { name: 'OP_jmp_if_false', imm: [{ name: 'offset', size: 2 }], doc: 'Jump if falsey' },
    { name: 'OP_inc_loc', imm: [{ name: 'index', size: 1 }], feature: 'shortOpcodes', doc: 'Increment local (short)' },
    { name: 'OP_inc_loc_u16', imm: [{ name: 'index', size: 2 }], doc: 'Increment local (u16)' },
    { name: 'OP_return_undef', doc: 'Return undefined (implicit)' },
];
const bigIntExtra = [
    { name: 'OP_add_bigint', feature: 'bigInt', doc: 'BigInt addition specialized' }
];
function filterAndNumber(opcodes, features) {
    const list = [];
    for (const op of opcodes) {
        if (op.feature === 'bigInt' && !features.bigInt)
            continue;
        if (op.feature === 'shortOpcodes' && !features.shortOpcodes)
            continue;
        list.push(op);
    }
    return list;
}
function gen() {
    const cfgPath = (0, node_path_1.resolve)(process.cwd(), 'opcodes.config.json');
    const cfg = JSON.parse((0, node_fs_1.readFileSync)(cfgPath, 'utf8'));
    let ops = [...baseOpcodes, ...bigIntExtra];
    ops = filterAndNumber(ops, cfg.features);
    const enumLines = [];
    const metaLines = [];
    enumLines.push('export enum OpCode {');
    ops.forEach((op, idx) => {
        enumLines.push(`  ${op.name} = ${idx},`);
        const imm = op.imm ? JSON.stringify(op.imm) : 'undefined';
        const doc = op.doc?.replace(/`/g, '\\`') || '';
        metaLines.push(`  { name: '${op.name}', size: 1 + ${(op.imm || []).reduce((a, b) => a + b.size, 0)}, imm: ${imm}, doc: \`${doc}\` },`);
    });
    enumLines.push('}');
    const content = `// Auto-generated by scripts/gen-opcodes.ts. Do not edit manually.\n` +
        `// Features => bigInt: ${cfg.features.bigInt}, shortOpcodes: ${cfg.features.shortOpcodes}\n` +
        `${enumLines.join('\n')}\n\n` +
        `export interface OpMeta { name: string; size: number; imm?: Array<{ name: string; size: number }>; doc?: string }\n` +
        `export const OPCODE_META: OpMeta[] = [\n${metaLines.join('\n')}\n] as const\n\n` +
        `export const OPCODE_INDEX: Record<string, number> = Object.fromEntries(OPCODE_META.map((m,i)=>[m.name,i]))\n`;
    (0, node_fs_1.writeFileSync)((0, node_path_1.resolve)(process.cwd(), 'src/opcodes.ts'), content, 'utf8');
}
if (require.main === module) {
    gen();
}
