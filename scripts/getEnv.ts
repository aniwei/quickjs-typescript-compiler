import * as fs from 'node:fs'
import { QuickJSLib } from './QuickJSLib'

type Atom = { id: number; key: string }
type Opcode = { name: string; code: number, nPop: number, nPush: number, size?: number, fmt: number }

function toEnumKey(raw: string, prefix: string): string {
  if (prefix === 'ATOM') {
    return `JS_ATOM_${raw}`;
  }

  if (prefix === 'OP') {
    return `OP_${raw}`;
  }

  return raw;
}

async function main() {
  const compileOptions = await QuickJSLib.getCompileOptions()
  const [bytecodeVersion, firstAtomId, compileFlagEnums] = await Promise.all([
    QuickJSLib.getBytecodeVersion(),
    QuickJSLib.getFirstAtomId(),
    QuickJSLib.getCompileFlagEnums()
  ])
  let supportsShortOpcodes = (compileOptions & compileFlagEnums.COMPILE_FLAG_SHORT_OPCODES) !== 0

  const [atomsList, opcodeList] = await Promise.all([
    QuickJSLib.getAllAtoms(),
    QuickJSLib.getAllOpcodes(),
  ])
  const opformatRecord = await QuickJSLib.getAllOpcodeFormats()
  const bytecodeTagRecord = await QuickJSLib.getAllBytecodeTags()
  const functionKindRecord = await QuickJSLib.getFunctionKinds()
  const jsModeRecord = await QuickJSLib.getJSModes()
  const pc2LineRecord = await QuickJSLib.getPC2LineCodes()

  // 去重与清洗 atoms（按 id 去重，优先保留首次出现的名称）
  const seenAtomIds = new Set<number>()
  const atomEntries: Array<{ key: string; id: number }> = []
  const usedAtomEnumKeys = new Set<string>()

  for (const a of atomsList as Atom[]) {
    if (seenAtomIds.has(a.id)) continue
    let enumKey = toEnumKey(a.key, 'ATOM')
    // 处理可能的重名（不同原始 key 清洗后重名）
    let candidate = enumKey
    let dedup = 1
    while (usedAtomEnumKeys.has(candidate)) {
      candidate = `${enumKey}_${++dedup}`
    }
    enumKey = candidate
    usedAtomEnumKeys.add(enumKey)
    seenAtomIds.add(a.id)
    atomEntries.push({ key: enumKey, id: a.id })
  }

  // Opcodes 与 OpFormats 也做有序输出（按 id/code 排序）
  const opcodes = (opcodeList as Opcode[]).slice().sort((a, b) => a.code - b.code)
  const opformats = Object.entries(opformatRecord as Record<string, number>)
    .map(([name, id]) => ({ name, id }))
    .sort((a, b) => a.id - b.id)
  const bytecodeTags = Object.entries(bytecodeTagRecord as Record<string, number>)
    .map(([name, id]) => ({ id: Number(id), name }))
    .sort((a, b) => a.id - b.id)
  const compileFlags = Object.entries(compileFlagEnums as Record<string, number>)
    .map(([name, id]) => ({ name, id }))
    .sort((a, b) => a.id - b.id)
  const functionKinds = Object.entries(functionKindRecord as Record<string, number>)
    .map(([name, id]) => ({ name, id }))
    .sort((a, b) => a.id - b.id)
  const jsModes = Object.entries(jsModeRecord as Record<string, number>)
    .map(([name, id]) => ({ name, id }))
    .sort((a, b) => a.id - b.id)
  const pc2Lines = Object.entries(pc2LineRecord as Record<string, number>)
    .map(([name, id]) => ({ name, id }))
    .sort((a, b) => a.id - b.id)
  
  

  const header = `// This file is auto-generated by scripts/getEnv.ts
// Do not edit manually.
// Generated at: ${new Date().toISOString()}
`

  const compileFlagsEnum = `export enum CompileFlags {
${compileFlags.map(f => `  ${f.name} = ${f.id},`).join('\n')}
}
`

  const opformatEnum = `export enum OpFormat {
${opformats.map(f => `  ${f.name} = ${f.id},`).join('\n')}
}
`

  const bytecodeTagsEnum = `export enum BytecodeTag {
${bytecodeTags.map(f => `  ${f.name} = ${f.id},`).join('\n')}
}
`

  const functionKindEnum = `export enum FunctionKind {
${functionKinds.map(f => `  ${f.name} = ${f.id},`).join('\n')}
}
`

  const pc2LineEnum = `export enum PC2Line {
${pc2Lines.map(m => `  ${m.name} = ${m.id},`).join('\n')}
}
`

  const jsModeEnum = `export enum JSMode {
${jsModes.map(m => `  ${m.name} = ${m.id},`).join('\n')}
}
`

  const opcodeEnum = `export enum Opcode {
${opcodes.map(o => `  ${toEnumKey(o.name, 'OP')} = ${o.code},`).join('\n')}
}
`

  // 直接导出从 QuickJS 名称（如 'add','push_i32'）到数值 code 的映射，便于 TS 侧使用
  const opcodeNameToCode = `export const OPCODE_NAME_TO_CODE: Record<string, number> = {
${opcodes.map(o => `  ${JSON.stringify(o.name)}: ${o.code},`).join('\n')}
}
`

  const atomEnum = `export enum JSAtom {
${atomEntries.map(a => `  ${a.key} = ${a.id},`).join('\n')}
}
`

  // 额外导出一个从 id 到原始字符串名称的映射，供编译器原子表初始化使用
  const uniqueAtoms = (atomsList as Atom[])
    .filter((a, idx, arr) => arr.findIndex(x => x.id === a.id) === idx)
    .sort((a, b) => a.id - b.id)

  const atomStrings = `export const ATOM_STRINGS: Record<number, string> = {
${uniqueAtoms.map(a => `  ${a.id}: ${JSON.stringify(a.key)},`).join('\n')}
}
`

  // Base opcode metadata (id/size/nPop/nPush/format) centralized in env
  // Short opcodes: we also export a subset SHORT_OPCODE_DEFS derived from wasm opcode metadata,
  // guarded by supportsShortOpcodes so that consumers don't need to re-encode details.
  const idToFormatName = new Map<number, string>(opformats.map(f => [f.id, f.name]))
  const sizeByFormat: Record<string, number> = {
    NONE: 1,
    NONE_INT: 1,
    NONE_LOC: 1,
    I8: 2,
    I16: 3,
    U8: 2,
    U16: 3,
    I32: 5,
    CONST8: 2,
    CONST: 5,
    ATOM: 5,
    LOC: 3,
    ARG: 3,
    LABEL8: 2,
    LABEL16: 3,
    LABEL: 5,
    NPOPX: 1, // short call variants have no extra bytes
    NPOP: 3,
  }

  const opcodeDefs = `export interface OpcodeDefinition {
  id: string
  size: number
  nPop: number
  nPush: number
  format: OpFormat
}

export const OPCODE_DEFS: Record<string, OpcodeDefinition> = {
${opcodes
  .map(o => {
    const key = toEnumKey(o.name, 'OP')
    const fmtName = idToFormatName.get(o.fmt) || 'NONE'
    const sz = o.size ?? sizeByFormat[fmtName] ?? 1
    return `  ${key}: { id: ${JSON.stringify(o.name)}, size: ${sz}, nPop: ${o.nPop}, nPush: ${o.nPush}, format: OpFormat.${fmtName} },`
  })
  .join('\n')}
}
`

  // Define the set of short opcode names as per quickjs-opcode.h #if SHORT_OPCODES block.
  // We intentionally keep this list small and explicit to avoid ambiguity with similar opcodes.
  const SHORT_OPCODE_NAME_SET = new Set<string>([
    'push_minus1', 'push_0', 'push_1', 'push_2', 'push_3', 'push_4', 'push_5', 'push_6', 'push_7',
    'push_i8', 'push_i16', 'push_const8', 'fclosure8', 'push_empty_string',
    'get_loc8', 'put_loc8', 'set_loc8',
    'get_loc0', 'get_loc1', 'get_loc2', 'get_loc3',
    'put_loc0', 'put_loc1', 'put_loc2', 'put_loc3',
    'set_loc0', 'set_loc1', 'set_loc2', 'set_loc3',
    'get_arg0', 'get_arg1', 'get_arg2', 'get_arg3',
    'put_arg0', 'put_arg1', 'put_arg2', 'put_arg3',
    'set_arg0', 'set_arg1', 'set_arg2', 'set_arg3',
    'get_var_ref0', 'get_var_ref1', 'get_var_ref2', 'get_var_ref3',
    'put_var_ref0', 'put_var_ref1', 'put_var_ref2', 'put_var_ref3',
    'set_var_ref0', 'set_var_ref1', 'set_var_ref2', 'set_var_ref3',
    'get_length',
    'if_false8', 'if_true8', 'goto8', 'goto16',
    'call0', 'call1', 'call2', 'call3',
    'is_undefined', 'is_null', 'typeof_is_undefined', 'typeof_is_function',
  ])

  if (!supportsShortOpcodes) {
    const opcodeNameSet = new Set(opcodes.map((o) => o.name))
    if (Array.from(SHORT_OPCODE_NAME_SET).some((name) => opcodeNameSet.has(name))) {
      supportsShortOpcodes = true
    }
  }

  const shortOpcodeDefs = `export const SHORT_OPCODE_DEFS: Record<string, OpcodeDefinition> = ${supportsShortOpcodes ? '{\n' + opcodes
    .filter(o => SHORT_OPCODE_NAME_SET.has(o.name))
    .map(o => {
      const key = toEnumKey(o.name, 'OP')
      const fmtName = idToFormatName.get(o.fmt) || 'NONE'
      const sz = o.size ?? sizeByFormat[fmtName] ?? 1
      return `  ${key}: { id: ${JSON.stringify(o.name)}, size: ${sz}, nPop: ${o.nPop}, nPush: ${o.nPush}, format: OpFormat.${fmtName} },`
    })
    .join('\n') + '\n}' : '{}'}
`

  const envBlock = `export interface Env {
  bytecodeVersion: number
  compileOptions: number
  firstAtomId: number
  supportsShortOpcodes: boolean
}

export const env = {
  bytecodeVersion: ${bytecodeVersion},
  compileOptions: ${compileOptions},
  firstAtomId: ${firstAtomId},
  supportsShortOpcodes: ${supportsShortOpcodes},
} as const
`

  const content = header + '\n' + compileFlagsEnum + '\n' + bytecodeTagsEnum + '\n' + functionKindEnum + '\n' + jsModeEnum + '\n' + pc2LineEnum + '\n' + opformatEnum + '\n' + opcodeEnum + '\n' + opcodeNameToCode + '\n' + atomEnum + '\n' + atomStrings + '\n' + opcodeDefs + '\n' + shortOpcodeDefs + '\n' + envBlock

  fs.writeFileSync('src/env.ts', content, 'utf-8')
  console.log('✓ Environment file src/env.ts generated successfully')
}

main().catch(e => {
  console.error(e)
  process.exit(1)
})
