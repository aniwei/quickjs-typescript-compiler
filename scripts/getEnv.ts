import * as fs from 'node:fs'
import { QuickJSLib } from './QuickJSLib'

type Atom = { id: number; key: string }
type Opcode = { name: string; code: number, nPop: number, nPush: number, size?: number, fmt: number }

function toEnumKey(raw: string, prefix: string): string {
  // 1) 将字符串转为大写
  let key = String(raw).toUpperCase()
  // 2) 非字母数字与 $ 替换为下划线
  key = key.replace(/[^A-Z0-9$]/g, '_')
  // 3) 避免以数字开头
  if (/^[0-9]/.test(key)) key = `${prefix}_${key}`
  // 4) 避免空键
  if (!key.length) key = `${prefix}_EMPTY`
  // 5) 避免重复下划线的冗余
  key = key.replace(/_+/g, '_')
  // 6) 去除首尾下划线
  key = key.replace(/^_+|_+$/g, '')
  // 再次兜底
  if (!key.length) key = `${prefix}_EMPTY`
  return key
}

async function main() {
  const [compileOptions, bytecodeVersion, firstAtomId] = await Promise.all([
    QuickJSLib.getCompileOptions(),
    QuickJSLib.getBytecodeVersion(),
    QuickJSLib.getFirstAtomId(),
  ])

  const [atomsList, opcodeList] = await Promise.all([
    QuickJSLib.getAllAtoms(),
    QuickJSLib.getAllOpcodes(),
  ])
  const opformatRecord = await QuickJSLib.getAllOpcodeFormats()

  // 去重与清洗 atoms（按 id 去重，优先保留首次出现的名称）
  const seenAtomIds = new Set<number>()
  const atomEntries: Array<{ key: string; id: number }> = []
  const usedAtomEnumKeys = new Set<string>()

  for (const a of atomsList as Atom[]) {
    if (seenAtomIds.has(a.id)) continue
    let enumKey = toEnumKey(a.key, 'ATOM')
    // 处理可能的重名（不同原始 key 清洗后重名）
    let candidate = enumKey
    let dedup = 1
    while (usedAtomEnumKeys.has(candidate)) {
      candidate = `${enumKey}_${++dedup}`
    }
    enumKey = candidate
    usedAtomEnumKeys.add(enumKey)
    seenAtomIds.add(a.id)
    atomEntries.push({ key: enumKey, id: a.id })
  }

  // Opcodes 与 OpFormats 也做有序输出（按 id/code 排序）
  const opcodes = (opcodeList as Opcode[]).slice().sort((a, b) => a.code - b.code)
  const opformats = Object.entries(opformatRecord as Record<string, number>)
    .map(([name, id]) => ({ name, id }))
    .sort((a, b) => a.id - b.id)

  const header = `// This file is auto-generated by scripts/getEnv.ts
// Do not edit manually.
// Generated at: ${new Date().toISOString()}
`

  const compiledFlagsEnum = `export enum CompiledFlags {
  COMPILED_FLAG_NONE = 0,
  COMPILED_FLAG_DUMP = 1 << 0,
  COMPILED_FLAG_BIGNUM = 1 << 1,
}
`

  const opformatEnum = `export enum OpFormat {
${opformats.map(f => `  ${toEnumKey(f.name, 'OPFMT')} = ${f.id},`).join('\n')}
}
`

  const opcodeEnum = `export enum Opcode {
${opcodes.map(o => `  ${toEnumKey(o.name, 'OP')} = ${o.code},`).join('\n')}
}
`

  // 直接导出从 QuickJS 名称（如 'add','push_i32'）到数值 code 的映射，便于 TS 侧使用
  const opcodeNameToCode = `export const OPCODE_NAME_TO_CODE: Record<string, number> = {
${opcodes.map(o => `  ${JSON.stringify(o.name)}: ${o.code},`).join('\n')}
}
`

  const atomEnum = `export enum JSAtom {
${atomEntries.map(a => `  ${a.key} = ${a.id},`).join('\n')}
}
`

  // 额外导出一个从 id 到原始字符串名称的映射，供编译器原子表初始化使用
  const uniqueAtoms = (atomsList as Atom[])
    .filter((a, idx, arr) => arr.findIndex(x => x.id === a.id) === idx)
    .sort((a, b) => a.id - b.id)

  const atomStrings = `export const ATOM_STRINGS: Record<number, string> = {
${uniqueAtoms.map(a => `  ${a.id}: ${JSON.stringify(a.key)},`).join('\n')}
}
`

  const envBlock = `export interface Env {
  bytecodeVersion: number
  compileOptions: number
  firstAtomId: number
}

export const env = {
  bytecodeVersion: ${bytecodeVersion},
  compileOptions: ${compileOptions},
  firstAtomId: ${firstAtomId},
} as const
`

  // Base opcode metadata (id/size/nPop/nPush/format) centralized in env
  // Note: short opcodes are produced conditionally in TS by getShortOpcodes()
  const idToFormatName = new Map<number, string>(opformats.map(f => [f.id, f.name]))
  const sizeByFormat: Record<string, number> = {
    NONE: 1,
    NONE_INT: 1,
    NONE_LOC: 1,
    I8: 2,
    I16: 3,
    U8: 2,
    U16: 3,
    I32: 5,
    CONST8: 2,
    CONST: 5,
    ATOM: 5,
    LOC: 3,
    ARG: 3,
    LABEL8: 2,
    LABEL16: 3,
    LABEL: 5,
    NPOPX: 1, // short call variants have no extra bytes
    NPOP: 3,
  }

  const opcodeDefs = `export interface OpcodeDefinition {
  id: string
  size: number
  nPop: number
  nPush: number
  format: OpFormat
}

export const OPCODE_DEFS: Record<string, OpcodeDefinition> = {
${opcodes
  .map(o => {
    const key = toEnumKey(o.name, 'OP')
    const fmtName = idToFormatName.get(o.fmt) || 'NONE'
    const sz = o.size ?? sizeByFormat[fmtName] ?? 1
    return `  ${key}: { id: ${JSON.stringify(o.name)}, size: ${sz}, nPop: ${o.nPop}, nPush: ${o.nPush}, format: OpFormat.${toEnumKey(fmtName, 'OPFMT')} },`
  })
  .join('\n')}
}
`

  const content = header + '\n' + compiledFlagsEnum + '\n' + opformatEnum + '\n' + opcodeEnum + '\n' + opcodeNameToCode + '\n' + atomEnum + '\n' + atomStrings + '\n' + opcodeDefs + '\n' + envBlock

  fs.writeFileSync('src/env.ts', content, 'utf-8')
  console.log('✓ Environment file src/env.ts generated successfully')
}

main().catch(e => {
  console.error(e)
  process.exit(1)
})
