import * as fs from 'node:fs'
import { QuickJSLib } from './QuickJSLib'

type Atom = { id: number; key: string }
type Opcode = { name: string; code: number }

function toEnumKey(raw: string, prefix: string): string {
  // 1) 将字符串转为大写
  let key = String(raw).toUpperCase()
  // 2) 非字母数字与 $ 替换为下划线
  key = key.replace(/[^A-Z0-9$]/g, '_')
  // 3) 避免以数字开头
  if (/^[0-9]/.test(key)) key = `${prefix}_${key}`
  // 4) 避免空键
  if (!key.length) key = `${prefix}_EMPTY`
  // 5) 避免重复下划线的冗余
  key = key.replace(/_+/g, '_')
  // 6) 去除首尾下划线
  key = key.replace(/^_+|_+$/g, '')
  // 再次兜底
  if (!key.length) key = `${prefix}_EMPTY`
  return key
}

async function main() {
  const [compileFlags, bytecodeVersion, firstAtomId] = await Promise.all([
    QuickJSLib.getCompileOptions(),
    QuickJSLib.getBytecodeVersion(),
    QuickJSLib.getFirstAtomId(),
  ])

  const [atomsList, opcodeList] = await Promise.all([
    QuickJSLib.getAllAtoms(),
    QuickJSLib.getAllOpcodes(),
  ])
  const opformatRecord = await QuickJSLib.getAllOpcodeFormats()

  // 去重与清洗 atoms（按 id 去重，优先保留首次出现的名称）
  const seenAtomIds = new Set<number>()
  const atomEntries: Array<{ key: string; id: number }> = []
  const usedAtomEnumKeys = new Set<string>()

  for (const a of atomsList as Atom[]) {
    if (seenAtomIds.has(a.id)) continue
    let enumKey = toEnumKey(a.key, 'ATOM')
    // 处理可能的重名（不同原始 key 清洗后重名）
    let candidate = enumKey
    let dedup = 1
    while (usedAtomEnumKeys.has(candidate)) {
      candidate = `${enumKey}_${++dedup}`
    }
    enumKey = candidate
    usedAtomEnumKeys.add(enumKey)
    seenAtomIds.add(a.id)
    atomEntries.push({ key: enumKey, id: a.id })
  }

  // Opcodes 与 OpFormats 也做有序输出（按 id/code 排序）
  const opcodes = (opcodeList as Opcode[]).slice().sort((a, b) => a.code - b.code)
  const opformats = Object.entries(opformatRecord as Record<string, number>)
    .map(([name, id]) => ({ name, id }))
    .sort((a, b) => a.id - b.id)

  const header = `// This file is auto-generated by scripts/getEnv.ts
// Do not edit manually.
// Generated at: ${new Date().toISOString()}
`

  const compiledFlagsEnum = `export enum CompiledFlags {
  COMPILED_FLAG_NONE = 0,
  COMPILED_FLAG_DUMP = 1 << 0,
  COMPILED_FLAG_BIGNUM = 1 << 1,
}
`

  const opformatEnum = `export enum OpFormat {
${opformats.map(f => `  ${toEnumKey(f.name, 'OPFMT')} = ${f.id},`).join('\n')}
}
`

  const opcodeEnum = `export enum Opcode {
${opcodes.map(o => `  ${toEnumKey(o.name, 'OP')} = ${o.code},`).join('\n')}
}
`

  const atomEnum = `export enum JSAtom {
${atomEntries.map(a => `  ${a.key} = ${a.id},`).join('\n')}
}
`

  const envBlock = `export interface Env {
  bytecodeVersion: number
  compileOptions: number
  firstAtomId: number
}

export const env = ${JSON.stringify({
    bytecodeVersion,
    compileFlags,
    firstAtomId,
  }, null, 2)} as const
`

  const content = header + '\n' + compiledFlagsEnum + '\n' + opformatEnum + '\n' + opcodeEnum + '\n' + atomEnum + '\n' + envBlock

  fs.writeFileSync('src/env.ts', content, 'utf-8')
  console.log('✓ Environment file src/env.ts generated successfully')
}

main().catch(e => {
  console.error(e)
  process.exit(1)
})
