#!/usr/bin/env node

/**
 * Command Line Interface for QuickJS TypeScript Compiler
 */

import fs from 'fs/promises'
import path from 'path'
import { QuickJSLib } from '../scripts/QuickJSLib'
import { TypeScriptCompiler, CompileFlags } from './index'
import { PC2Line } from './env'

const PC2LINE_BASE = PC2Line.PC2LINE_BASE
const PC2LINE_RANGE = PC2Line.PC2LINE_RANGE
const PC2LINE_OP_FIRST = PC2Line.PC2LINE_OP_FIRST

interface CLIOptions extends CompileFlags {
  output?: string
  disasm?: boolean
  cfg?: boolean
  pc2line?: boolean
  verbose?: boolean
  runWasm?: boolean
}

async function main() {
  const args = process.argv.slice(2)
  
  if (args.length === 0) {
    console.log('Usage: quickjs-ts-compiler <input.ts> [options]')
    console.log('Options:')
    console.log('  -o, --output <file>    Output bytecode file')
    console.log('  --bigint              Enable BigInt support')
    console.log('  --dump                Enable debug dump')
    console.log('  --no-shortcode        Disable short opcode optimization')
    console.log('  --debug               Enable debug mode')
    console.log('  --no-strict           Disable strict mode')
    console.log('  --disasm              Disassemble bytecode (for debugging)')
    console.log('  --cfg             Show control flow graph')
    console.log('  --pc2line             Show PC to line mapping')
    console.log('  --run-wasm            Execute generated bytecode using QuickJS WASM')
    console.log('  -v, --verbose         Verbose output')
    return
  }
  
  const inputFile = args[0]
  const options: CLIOptions = {}
  
  // Parse arguments
  for (let i = 1; i < args.length; i++) {
    const arg = args[i]
    switch (arg) {
      case '-o':
      case '--output':
        options.output = args[++i]
        break
      case '--bigint':
        options.bigInt = true
        break
      case '--dump':
        options.dump = true
        break
      case '--no-shortcode':
        options.shortCode = false
        break
      case '--debug':
        options.debug = true
        break
      case '--no-strict':
        options.strictMode = false
        break
      case '--disasm':
        options.disasm = true
        break
      case '--cfg':
        options.cfg = true
        break
      case '--pc2line':
        options.pc2line = true
        break
      case '--run-wasm':
        options.runWasm = true
        break
      case '-v':
      case '--verbose':
        options.verbose = true
        break
      default:
        console.warn(`Unknown option: ${arg}`)
    }
  }
  
  try {
    await compileTsFile(inputFile, options)
  } catch (error) {
    console.error('Compilation failed:', error instanceof Error ? error.message : error)
    process.exit(1)
  }
}

async function compileTsFile(inputFile: string, options: CLIOptions) {
  // Resolve input file path
  const inputPath = path.resolve(inputFile)
  
  // Check if input file exists
  try {
    await fs.access(inputPath)
  } catch {
    throw new Error(`Input file not found: ${inputPath}`)
  }
  
  if (options.verbose) {
    console.log(`Compiling: ${inputPath}`)
    console.log('Options:', {
      bigInt: options.bigInt,
      dump: options.dump,
      shortCode: options.shortCode,
      debug: options.debug,
      strictMode: options.strictMode,
      disasm: options.disasm
    })
  }
  
  // Create compiler with options
  const compilerOptions: CompileFlags = {
    bigInt: options.bigInt,
    dump: options.dump,
    shortCode: options.shortCode !== false, // Default to true unless explicitly disabled
    debug: options.debug,
    strictMode: options.strictMode !== false // Default to true unless explicitly disabled
  }
  
  const compiler = new TypeScriptCompiler(compilerOptions)
  
  // Compile file
  const startTime = Date.now()
  const { bytecode, functionDef } = await compiler.compileFileWithArtifacts(inputPath)
  const compileTime = Date.now() - startTime
  
  if (options.verbose) {
    console.log(`Compilation completed in ${compileTime}ms`)
    console.log(`Bytecode size: ${bytecode.length} bytes`)
  }
  
  // Determine output file
  let outputPath: string
  if (options.output) {
    outputPath = path.resolve(options.output)
  } else {
    const parsed = path.parse(inputPath)
    outputPath = path.join(parsed.dir, parsed.name + '.qbc') // QuickJS Bytecode
  }
  
  // Write bytecode to file
  await fs.writeFile(outputPath, bytecode)
  
  if (options.verbose) {
    console.log(`Bytecode written to: ${outputPath}`)
  }
  
  // Debug options
  if (options.disasm) {
    await disassembleBytecode(bytecode, inputPath)
  }
  
  if (options.cfg) {
    console.log('Control Flow Graph generation not implemented yet')
  }
  
  if (options.pc2line) {
    const table = functionDef.bytecode.pc2line
    if (!table || table.length === 0) {
      console.log('⚠️  pc2line 表为空')
    } else {
      printPc2LineTable(table)
    }
  }

  if (options.runWasm) {
    if (options.verbose) {
      console.log('🚀 Running bytecode with QuickJS WASM...')
    }
    try {
      await QuickJSLib.runWithBinaryPath(outputPath)
      console.log('✓ Bytecode executed successfully via WASM')
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error)
      throw new Error(`Failed to run bytecode with QuickJS WASM: ${message}`)
    }
  }
  
  console.log('✓ Compilation successful')
}

function printPc2LineTable(buffer: number[]) {
  const hexBytes = buffer.map((byte) => `0x${byte.toString(16).padStart(2, '0')}`)
  console.log('📦 pc2line 原始字节:', hexBytes.join(' '))

  const entries = decodePc2line(buffer)
  console.log('┏━━╸PC ╺━━╸行 ╺━━╸列 ╺━━╸ΔPC ╺━━╸Δ行 ╺━━╸Δ列')
  for (const entry of entries) {
    const pcText = entry.pc.toString().padStart(4, ' ')
    const lineText = (entry.line + 1).toString().padStart(3, ' ')
    const colText = (entry.column + 1).toString().padStart(3, ' ')
    const deltaPc = entry.deltaPc.toString().padStart(3, ' ')
    const deltaLine = entry.deltaLine.toString().padStart(3, ' ')
    const deltaColumn = entry.deltaColumn.toString().padStart(3, ' ')
    console.log(`┃ ${pcText} → ${lineText} : ${colText}  [Δpc=${deltaPc} Δ行=${deltaLine} Δ列=${deltaColumn}]`)
  }
}

function decodePc2line(buffer: number[]) {
  const data = buffer.slice()
  let offset = 0
  const readULEB = (): number => {
    let result = 0
    let shift = 0
    while (true) {
      const byte = data[offset++]
      result |= (byte & 0x7f) << shift
      if ((byte & 0x80) === 0) break
      shift += 7
    }
    return result >>> 0
  }
  const readSLEB = (): number => {
    const encoded = readULEB()
    return ((encoded >>> 1) ^ -(encoded & 1)) | 0
  }

  const entries: Array<{ pc: number; line: number; column: number; deltaPc: number; deltaLine: number; deltaColumn: number }> = []
  let pc = 0
  let line = readULEB()
  let column = readULEB()
  entries.push({ pc, line, column, deltaPc: 0, deltaLine: 0, deltaColumn: 0 })

  while (offset < data.length) {
    const op = data[offset++]
    let diffPc: number
    let diffLine: number

    if (op === 0) {
      diffPc = readULEB()
      diffLine = readSLEB()
    } else {
      const encoded = op - PC2LINE_OP_FIRST
      diffPc = Math.floor(encoded / PC2LINE_RANGE)
      diffLine = (encoded % PC2LINE_RANGE) + PC2LINE_BASE
    }
    const diffColumn = readSLEB()

    pc += diffPc
    line += diffLine
    column += diffColumn

    entries.push({ pc, line, column, deltaPc: diffPc, deltaLine: diffLine, deltaColumn: diffColumn })
  }

  return entries
}

async function disassembleBytecode(bytecode: Uint8Array, sourceFile: string) {
  console.log('\n--- Disassembly ---')
  console.log(`Source: ${sourceFile}`)
  console.log(`Bytecode size: ${bytecode.length} bytes`)
  console.log('')
  
  // Simple hex dump for now
  // TODO: Implement proper disassembler
  for (let i = 0; i < bytecode.length; i += 16) {
    const chunk = bytecode.slice(i, i + 16)
    const hex = Array.from(chunk)
      .map(b => b.toString(16).padStart(2, '0'))
      .join(' ')
    const ascii = Array.from(chunk)
      .map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.')
      .join('')
    
    console.log(`${i.toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`)
  }
  
  console.log('--- End Disassembly ---\n')
}

// Run CLI
if (require.main === module) {
  main().catch(error => {
    console.error('CLI Error:', error)
    process.exit(1)
  })
}